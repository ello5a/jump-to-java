package oop;

public class test {
	// 메서드에 대해서 설명합니다! animal.java부터 보고 오세요
	int a;
	
	public int sum(int a, int b) {
		return a+b;
	}
	/*
	 * 위의 메서드는 전형적인 예이다
	 * 입력값 - int 자료형 a, int 자료형 b
	 * 리턴값 - int 자로형
	 * 
	 * 위처럼 입력값과 리턴값이 있는 메서드는 다음처럼 사용된다
	 * 리턴값을 받을 변수 = 객체.메서드명(입력인수1,입력인수2,..)
	 */
	// 입력값이 없는 메서드
	public String say() {
		return "hi";
	}
	/*
	 * 입력값 없음
	 * 리턴값 String 자료형
	 * 
	 * 입력값이 없는 메서드는 다음과 같이 사용한다
	 * 리턴값을 받을 변수 = 객체.메서드명();
	 */
	
	// 리턴값이 없는 메서드
	public void sum2(int a, int b) {
		System.out.println(a + "과 "+b+"의 합은 "+(a+b)+"입니다!!!");
	}
	/*
	 * 입력값 - int 자료형 a, int 자로형 b
	 * 리턴값 - void(없음)
	 * 리턴값이 없는 메서드는 다음처럼 사용한다
	 * 객체.메서드(입력인수1,인수2)
	 */
	
	//입력값도 없고 리턴도 없는 메서드
	public void Say() {
		System.out.println("hi");
	}
	/*
	 * 입력값 x
	 * 리턴값 x
	 * 
	 * 사용법은 단 한가지
	 * 객체.메서드명
	 */
	
	/*
	 * return의 또 다른 쓰임새
	 * 특별한 경우에 메서드를 빠저나가길 원할 때 return만 단독으로 서서 메서드를 즉시 빠저나갈 수 있다
	 */
	public void say_nick(String nick) {
		if("fool".equals(nick)) {
			return;
		}
		System.out.println("나의 별명은 "+nick+"입니다@!");
	}
	/*
	 * 위의 메서드는 입력값으로 nick 이란 변수를 받아서 문자열을 출력하는 메서드이다. 이 역시 리턴값은 없다
	 * 문자열을 출력한다는 것과 리턴값이 있다는 것은 전혀 다른내용이다.
	 * 참고로 return문만 써서 메서드를 빠저나가는 방법은 리턴 자료형이 void일때만 해당한다
	 */
	
	//메서드 내에서 선언된 변수의 사용범위
	public void vartest(int a) {
		a++;
	}
	// 위의 메서드는 입력으로 들어온 int 자료형의 값을 1만큼 증가시킨다..
	// 그렇다면 main 메서드에서는 무슨일이 생길까
	
	public int vartest1(int a) {
		a++;
		return a;
	}

	public void vertest2(test test) {
		test.a++;
	}
	
	
	
	
	public static void main(String[] args) {
		int a = 3;
		int b = 4;
		
		test mytest = new test();
		int c = mytest.sum(a, b);
		
		System.out.println(c);
		
		/*메서드의 입력값과 출력값
		 * 프로그래밍을 공부할 때 어려운 부분중 하나가 용어의 혼용이다.
		 * 입력값을 다른 말로 메서드의 인수, 입력인수 등으로 말하기도 하고 리턴값을 출력값, 결과 값, 돌려주는 값 등으로 말하기도 함
		 * 이렇게 별의별 용어들이 다른 말로 표현되지만 의미는 같은 경우가 많다. 이런거를 기억해 놓아야만 덜 햇갈릴것이다
		 * 메서드는 들어온 값을 가지고 어떤 처리를 하여 적절한 리턴값을 돌려주는 블랙박스와 같다
		 * 
		 * 입력 ---> 메서드(블랙박스) ----> 리턴값
		 * 
		 * 메서드의 구조를 알아보자
		 * 
		 * public 리턴자료형 메서드명 (입력자료1 입력변수2, 입력자료2 입력변수2, 입....)
		 * 		...
		 * 		return 리턴값;	// 리턴자료형이 void인 경우 return이 필요없다
		 * 
		 * 리턴자료형은 메서드 수행 후 돌려줄 값의 자료형을 의미한다. 메서드의 리턴값은 return 이라는 명령을 사용한다
		 * 메소드는 입출력 유무에 따라 다음과 같이 4가지로 분류할 수 있다.
		 * 입력과 출력이 모두 있는 메소드
		 * 입력과 출력이 모두 없는 메소드
		 * 입력은 없고 출력은 있는 메소드
		 * 입력은 있는 출력은 없고 메소드
		 */

		test mytest2 = new test();
		mytest2.vartest(a);
		System.out.println(a);
		/*
		 * 먼저 main 메서드에서 a라는 int자료형의 변수를 생성하고 값으로 3이 들어갔다. 그리고 vartest메서드의
		 * 입력값으로 a를 주어 호출했다. 그 다음에  a의 값을 출력하게 했다. 당연히 vartest 메서드에서 a의 값을
		 * 1만큼 증가시켰으나 실제로는 3이라는 결과 값이 나온다
		 * 
		 * 메서드 내에서 사용되는 변수는 메서드 안에서만 쓰는 변수라서 그렇다
		 * 즉 public void vartest(int a) 라는 문장에서 입력 인수를 뜻하는 변수 a는 메서드 안에서만 쓰는 변수
		 * 메서드 밖의 변수 a를 의미하는게 아니다
		 * 
		 * 이는 메서드에서 쓰이는 변수는 메서드 밖의 변수이름들과 전혀 상관없다. 그래서 메서드에서만 쓰이는 변수를
		 * 로컬 변수라고 부른다 
		 * 
		 * 만약 vartest의 입력값이 int 자료형이 아닌 객체라면 말이 달라진다. 객체를 메서드의 입력으로 넘기고
		 * 메서드가 객체의 속성값(객체변수 값)을 변경한다면 메서드 수행 이후에도 객체는 변경된 속성값을 유지한다
		 * 이러한 차이가 나는 이유는 메서드에 전다하는 입력 자료형의 형태 때문인데 메서드에 값을 전달하느냐 아니면
		 * 객체를 전달하느냐의 차이가 난다
		 * 그러면 메서드를 통해서 외브의 a를 1 증가시키는 메서드를 만들어보자
		 */
		a = mytest2.vartest1(a);
		System.out.println(a);
		
		/*
		 * 이번에는 메서드에 객체를 넘겨보자
		 */
		test atest = new test();
		atest.a = 1;
		atest.vertest2(atest);
		System.out.println(atest.a);
		
		/* 자 이제 설명타임
		 * 이전에는 a라는 int 변수를 main 메서드에서 선언했는데 이번에는 test클래스의 변수로 넣었다
		 * 그리고 vartest2 메서드는 다음과 같이 test클래스의 객체(atest)를 입력받아 해당 객체의 객체변수 a의 값을 1만큼
		 * 증가시켰다
		 * 
		 * 그리고 main메서드에서 vartest2메서드에 test클래스의 객체인 atest를 넘겼다
		 * 
		 * 여기서 주목할 점은 vartest2메서드의 입력 파라미터가 값이 아닌 test클래스의 객체라는데 있다
		 * 이렇게 메서드가 객체를 전달 받으면 메서드 내의 객체는 전달받은 객체 그 자체로 수행된다.
		 * 따라서 입력으로 전달받은 atest 객체의 객체변수 a의 값이 증가하게 된다
		 * 메서드가 입력항목이 값인지, 객체인지 구분하는 기준은 입력의 자료형이 primitive인지 reference인지에 따라 구분한다
		 * 
		 */
	}

}
